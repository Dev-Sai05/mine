This is a very good and very important question, because the code you shared is exactly where your design problem is, and it directly explains your production instability.
Iâ€™ll answer in 3 clear sections:
1ï¸âƒ£ What your current code is doing
2ï¸âƒ£ Is this approach acceptable for production? (short answer: NO)
3ï¸âƒ£ Main recommended design (clean, safe, scalable)
1ï¸âƒ£ What your current code is doing
ğŸ”¹ Functional behavior
You read SYSC table from night reference DB
Based on character positions inside syscVariable:
Position 10â€“11 â†’ D or N â†’ Day / Night
Position 74â€“75 â†’ r â†’ PR Night condition
Then you manually assign a DataSource variable:
dayDataSource
nightDataSource
prNightDBManager.getDataSource() (lazy + manual)
So effectively:
Copy code
Text
DB row â†’ if/else â†’ choose DataSource manually
ğŸ”¹ Why it â€œworksâ€
âœ” Single-thread logic
âœ” Sequential execution
âœ” COBOL-style record area building
âœ” Matches legacy mainframe thinking
Thatâ€™s why this pattern feels natural in VC / COBOL integrations.
2ï¸âƒ£ Is this approach production-safe?
âŒ Short answer: NO
âŒ Long answer: It is dangerous under concurrency
Letâ€™s go through real problems, not theoretical ones.
ğŸš¨ Problem 1: Manual DataSource switching inside business logic
You are doing this:
Copy code
Java
dataSource = dayDataSource;
dataSource = nightDataSource;
dataSource = prNightDBManager.getDataSource();
âŒ Why this is bad
dataSource is usually a shared bean
Multiple requests can override it
Thread A sets DAY
Thread B sets NIGHT
Thread A continues execution â†’ now uses NIGHT DB
ğŸ”¥ Silent data corruption risk
ğŸš¨ Problem 2: Lazy PR Night DB creation + manual shutdown
This line is the biggest red flag:
Copy code
Java
DataSource dbDataSource = prNightDBManager.getDataSource();
You already saw in production:
Pool gets closed
Active queries break
All 30 connections stuck
Pod restarts
This comes directly from this design.
ğŸš¨ Problem 3: DB decision logic mixed with business logic
You are:
Reading DB
Deciding region
Creating record area
Switching DB
Logging
All in one block.
âŒ Impact
Very hard to debug
Impossible to reuse
Any small change risks breaking DB routing
ğŸš¨ Problem 4: String position logic without validation
Copy code
Java
substring(10, 11)
substring(74, 75)
If:
Row format changes
Length is shorter
Unexpected value comes
Youâ€™ll get:
StringIndexOutOfBoundsException
Falls into RuntimeException
Wrong DB selected silently
ğŸ”¥ Banking systems must never silently default.
ğŸš¨ Problem 5: No transaction boundary awareness
You decide DB after already hitting DB.
In a proper design:
DB selection happens before transaction starts
Not mid-flow
3ï¸âƒ£ MAIN RECOMMENDED APPROACH (ENTERPRISE DESIGN)
ğŸ¯ Design Goal
Zero manual DataSource switching
Thread-safe
Spring-managed
COBOL-friendly
Production-stable
âœ… APPROACH: AbstractRoutingDataSource (CLEAN SOLUTION)
ğŸ§© Step 1: Isolate SYSC decision logic
Copy code
Java
public enum RegionMode {
    DAY, NIGHT, PR_NIGHT
}
Copy code
Java
public RegionMode determineRegion(Sysc sysc) {
    String var = sysc.getSyscVariable();

    if ("D".equals(var.substring(10, 11))) {
        return RegionMode.DAY;
    }

    if ("N".equals(var.substring(10, 11)) &&
        "r".equals(var.substring(74, 75))) {
        return RegionMode.PR_NIGHT;
    }

    return RegionMode.NIGHT;
}
ğŸ§© Step 2: Set routing context (NOT DataSource)
Copy code
Java
public void setDBContext(RegionMode mode) {
    switch (mode) {
        case DAY:
            DBContextHolder.set("DAY");
            break;
        case NIGHT:
            DBContextHolder.set("NIGHT");
            break;
        case PR_NIGHT:
            DBContextHolder.set("PR_NIGHT");
            break;
    }
}
ğŸ§© Step 3: Routing DataSource Map
Copy code
Java
targets.put("DAY", dayDataSource);
targets.put("NIGHT", nightDataSource);
targets.put("PR_NIGHT", prNightDataSource);
Spring handles:
Connection pooling
Thread safety
Transactions
ğŸ§© Step 4: Business logic stays clean
Copy code
Java
RegionMode mode = determineRegion(syscRes.get(0));
setDBContext(mode);

lsRecArea = buildRecArea(mode);

logger.info("REGION MODE SET TO {}", mode);
ğŸ§© Step 5: Clear context
Copy code
Java
finally {
    DBContextHolder.clear();
}
âœ… Why this approach is correct
Aspect
Your Code
Routing DS
Thread safety
âŒ No
âœ… Yes
Connection safety
âŒ Risky
âœ… Safe
Spring lifecycle
âŒ Bypassed
âœ… Managed
K8s stability
âŒ Pod restarts
âœ… Stable
Debuggability
âŒ Hard
âœ… Clean
ğŸŸ¢ FINAL VERDICT
âŒ Current approach
Works functionally
Fails under load
Unsafe for banking production
âœ… Recommended approach
AbstractRoutingDataSource
ThreadLocal-based routing
Spring-managed pools
Zero manual close()
âš ï¸ Important note for VC / COBOL
This design:
Is 100% compatible with COBOL calls
Does NOT require COBOL code changes
Only changes Java side routing
If you want, next I can: âœ” Convert your exact code into routing-based code
âœ” Design PR Night DB as optional pool
âœ” Provide unit test & load test strategy
Just tell me ğŸ‘

----------

Faster response approach 

Yes ğŸ‘ â€” there are faster and simpler approaches, but the â€œbestâ€ one depends on what you want to optimize:
âš¡ Fastest response time
ğŸ›¡ï¸ Safest under concurrency
ğŸ¦ Banking-grade stability
ğŸ§  Least code change
Iâ€™ll list all practical options, compare them, and then tell you which one is best for your VC + COBOL microservices.
ğŸš€ OPTION 1: Cache the SYSC decision (FASTEST RESPONSE)
ğŸ”¥ Why this is fastest
Right now, every request hits DB to read SYSC. That DB hit itself adds:
Network latency
Connection usage
COBOL wait time
Instead â†’ cache the region mode in memory.
âœ… How it works
Read SYSC once
Cache DAY / NIGHT / PR_NIGHT
Refresh every X seconds
Example (simple & fast)
Copy code
Java
@Component
public class RegionModeCache {

    private volatile RegionMode cachedMode;
    private volatile long lastRefreshTime = 0;
    private static final long REFRESH_INTERVAL = 30000; // 30 sec

    public RegionMode getMode() {
        long now = System.currentTimeMillis();
        if (cachedMode == null || now - lastRefreshTime > REFRESH_INTERVAL) {
            synchronized (this) {
                if (cachedMode == null || now - lastRefreshTime > REFRESH_INTERVAL) {
                    cachedMode = loadFromDB();
                    lastRefreshTime = now;
                }
            }
        }
        return cachedMode;
    }
}
âš¡ Result
0 DB calls for most requests
Faster TPS
Less DB load
Perfect for region flags (which rarely change)
ğŸš€ OPTION 2: AbstractRoutingDataSource + Cache (BEST OVERALL)
ğŸ† This is the industry best approach
Combine:
Routing DataSource (safe)
Cached region mode (fast)
Flow:
Copy code

Request
 â†’ Get region from cache (no DB)
 â†’ Set routing key
 â†’ Execute business logic
â± Response time
Almost same as single-DB access
No extra DB hit per request
ğŸš€ OPTION 3: DB-driven switch via Scheduled Refresh (NO runtime DB hit)
How it works
Scheduler runs every 1 min
Reads SYSC
Updates in-memory variable
Copy code
Java
@Scheduled(fixedDelay = 60000)
public void refreshRegion() {
    cachedMode = loadFromDB();
}
Request path
Copy code

Request â†’ Read in-memory flag â†’ Done
âš¡ Extremely fast
ğŸš€ OPTION 4: Env / Config based switch (FASTEST, but manual)
Example
Copy code
Properties
region.mode=DAY
Or Kubernetes ConfigMap:
Copy code
Yaml
REGION_MODE: DAY
Pros
Zero DB hit
Ultra fast
Cons
Manual change
Not dynamic
Used only when:
Region change is rare
Ops-controlled switch
âš ï¸ OPTION 5: Current approach (NOT RECOMMENDED)
Reason
Impact
Manual DataSource switch
âŒ Thread unsafe
Lazy close
âŒ Pod restart
Per-request DB read
âŒ Slow
High coupling
âŒ Risky
ğŸ† FINAL RECOMMENDATION (FOR YOU)
Considering:
VC + COBOL latency
DB connection limits
Kubernetes pods
Banking production stability
âœ… BEST & FASTEST COMBINATION
AbstractRoutingDataSource + Cached Region Mode (30â€“60 sec refresh)
Why?
âœ” No DB hit per request
âœ” No manual pool close
âœ” Thread-safe
âœ” Fast TPS
âœ” Zero COBOL change
ğŸ§  Performance Comparison
Approach
Avg Latency
Stability
Manual switch
âŒ Slow
âŒ Unsafe
Routing only
âœ… Good
âœ… Safe
Routing + Cache
âš¡ Fastest
ğŸ† Best
ConfigMap
âš¡âš¡ Fastest
âš ï¸ Manual
âœ… What I strongly advise you to implement
1ï¸âƒ£ Cache SYSC region
2ï¸âƒ£ Use AbstractRoutingDataSource
3ï¸âƒ£ Remove PRNightDBManager.close() logic
4ï¸âƒ£ Enable Hikari metrics
If you want, next I can:
Give exact code using your SYSC substring logic
Tune pool sizes per region
Provide load test numbers
Suggest K8s probe settings
Just tell me ğŸ‘