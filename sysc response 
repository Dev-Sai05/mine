This is a very good and very important question, because the code you shared is exactly where your design problem is, and it directly explains your production instability.
Iâ€™ll answer in 3 clear sections:
1ï¸âƒ£ What your current code is doing
2ï¸âƒ£ Is this approach acceptable for production? (short answer: NO)
3ï¸âƒ£ Main recommended design (clean, safe, scalable)
1ï¸âƒ£ What your current code is doing
ğŸ”¹ Functional behavior
You read SYSC table from night reference DB
Based on character positions inside syscVariable:
Position 10â€“11 â†’ D or N â†’ Day / Night
Position 74â€“75 â†’ r â†’ PR Night condition
Then you manually assign a DataSource variable:
dayDataSource
nightDataSource
prNightDBManager.getDataSource() (lazy + manual)
So effectively:
Copy code
Text
DB row â†’ if/else â†’ choose DataSource manually
ğŸ”¹ Why it â€œworksâ€
âœ” Single-thread logic
âœ” Sequential execution
âœ” COBOL-style record area building
âœ” Matches legacy mainframe thinking
Thatâ€™s why this pattern feels natural in VC / COBOL integrations.
2ï¸âƒ£ Is this approach production-safe?
âŒ Short answer: NO
âŒ Long answer: It is dangerous under concurrency
Letâ€™s go through real problems, not theoretical ones.
ğŸš¨ Problem 1: Manual DataSource switching inside business logic
You are doing this:
Copy code
Java
dataSource = dayDataSource;
dataSource = nightDataSource;
dataSource = prNightDBManager.getDataSource();
âŒ Why this is bad
dataSource is usually a shared bean
Multiple requests can override it
Thread A sets DAY
Thread B sets NIGHT
Thread A continues execution â†’ now uses NIGHT DB
ğŸ”¥ Silent data corruption risk
ğŸš¨ Problem 2: Lazy PR Night DB creation + manual shutdown
This line is the biggest red flag:
Copy code
Java
DataSource dbDataSource = prNightDBManager.getDataSource();
You already saw in production:
Pool gets closed
Active queries break
All 30 connections stuck
Pod restarts
This comes directly from this design.
ğŸš¨ Problem 3: DB decision logic mixed with business logic
You are:
Reading DB
Deciding region
Creating record area
Switching DB
Logging
All in one block.
âŒ Impact
Very hard to debug
Impossible to reuse
Any small change risks breaking DB routing
ğŸš¨ Problem 4: String position logic without validation
Copy code
Java
substring(10, 11)
substring(74, 75)
If:
Row format changes
Length is shorter
Unexpected value comes
Youâ€™ll get:
StringIndexOutOfBoundsException
Falls into RuntimeException
Wrong DB selected silently
ğŸ”¥ Banking systems must never silently default.
ğŸš¨ Problem 5: No transaction boundary awareness
You decide DB after already hitting DB.
In a proper design:
DB selection happens before transaction starts
Not mid-flow
3ï¸âƒ£ MAIN RECOMMENDED APPROACH (ENTERPRISE DESIGN)
ğŸ¯ Design Goal
Zero manual DataSource switching
Thread-safe
Spring-managed
COBOL-friendly
Production-stable
âœ… APPROACH: AbstractRoutingDataSource (CLEAN SOLUTION)
ğŸ§© Step 1: Isolate SYSC decision logic
Copy code
Java
public enum RegionMode {
    DAY, NIGHT, PR_NIGHT
}
Copy code
Java
public RegionMode determineRegion(Sysc sysc) {
    String var = sysc.getSyscVariable();

    if ("D".equals(var.substring(10, 11))) {
        return RegionMode.DAY;
    }

    if ("N".equals(var.substring(10, 11)) &&
        "r".equals(var.substring(74, 75))) {
        return RegionMode.PR_NIGHT;
    }

    return RegionMode.NIGHT;
}
ğŸ§© Step 2: Set routing context (NOT DataSource)
Copy code
Java
public void setDBContext(RegionMode mode) {
    switch (mode) {
        case DAY:
            DBContextHolder.set("DAY");
            break;
        case NIGHT:
            DBContextHolder.set("NIGHT");
            break;
        case PR_NIGHT:
            DBContextHolder.set("PR_NIGHT");
            break;
    }
}
ğŸ§© Step 3: Routing DataSource Map
Copy code
Java
targets.put("DAY", dayDataSource);
targets.put("NIGHT", nightDataSource);
targets.put("PR_NIGHT", prNightDataSource);
Spring handles:
Connection pooling
Thread safety
Transactions
ğŸ§© Step 4: Business logic stays clean
Copy code
Java
RegionMode mode = determineRegion(syscRes.get(0));
setDBContext(mode);

lsRecArea = buildRecArea(mode);

logger.info("REGION MODE SET TO {}", mode);
ğŸ§© Step 5: Clear context
Copy code
Java
finally {
    DBContextHolder.clear();
}
âœ… Why this approach is correct
Aspect
Your Code
Routing DS
Thread safety
âŒ No
âœ… Yes
Connection safety
âŒ Risky
âœ… Safe
Spring lifecycle
âŒ Bypassed
âœ… Managed
K8s stability
âŒ Pod restarts
âœ… Stable
Debuggability
âŒ Hard
âœ… Clean
ğŸŸ¢ FINAL VERDICT
âŒ Current approach
Works functionally
Fails under load
Unsafe for banking production
âœ… Recommended approach
AbstractRoutingDataSource
ThreadLocal-based routing
Spring-managed pools
Zero manual close()
âš ï¸ Important note for VC / COBOL
This design:
Is 100% compatible with COBOL calls
Does NOT require COBOL code changes
Only changes Java side routing
If you want, next I can: âœ” Convert your exact code into routing-based code
âœ” Design PR Night DB as optional pool
âœ” Provide unit test & load test strategy
Just tell me ğŸ‘